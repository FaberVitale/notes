webpackJsonp([0xc50ab8b56c2f],{472:function(e,n){e.exports={data:{markdownRemark:{html:'<h2>Description</h2>\n<p>Http is a <strong>stateless</strong> application level protocol that uses a request-response model.</p>\n<p>It operates by\nexchanging messages across a reliable transport(TCP) or\nsession-layer "connection".  </p>\n<h3>HTTP Client</h3>\n<p>a program that establishes a connection to a server for the purpose of\nsending one or more HTTP requests.  </p>\n<h3>HTTP Server</h3>\n<p>a program that accepts connections in order to service HTTP requests by sending\nHTTP responses.</p>\n<h3>Intermediaries</h3>\n<p>HTTP enables the use of intermediaries to satisfy requests through a\nchain of connections.  There are three common forms of HTTP\nintermediary: proxy, gateway, and tunnel.</p>\n<h3>proxy</h3>\n<p>A "proxy" is a message-forwarding agent that is selected by the\nclient, usually via local configuration rules, to receive requests\nfor some type(s) of absolute URI and attempt to satisfy those\nrequests via translation through the HTTP interface.</p>\n<h3>reverse-proxy or gateway</h3>\n<p>An intermediary server that acts as server for the client forwarding requests to\nanother server not known to the client.\nUsed for perfomance, encapsulation.</p>\n<h3>tunnel</h3>\n<p>a blind relay between two connections without\nchanging the messages.  Once active, a tunnel is not considered a\nparty to the HTTP communication.</p>\n<h2>Message format</h2>\n<pre><code>  HTTP-message   = start-line\n                  *( header-field CRLF )\n                  CRLF\n                  [ message-body ]\n</code></pre>\n<h3>Start Line</h3>\n<ul>\n<li>request-line: if it a request</li>\n<li>status-line: if it is a response.</li>\n</ul>\n<h4>Request Line</h4>\n<pre><code>request-line   = method SP request-target SP HTTP-version CRLF\n</code></pre>\n<ul>\n<li>method: a valid http method,</li>\n<li>SP: a single white space <code>\\\\u0020</code></li>\n<li>request-target: relative, absolute url, asterick or, authority part of url </li>\n<li>HTTP-version: example: HTTP/1.1</li>\n</ul>\n<h4>Status Line</h4>\n<pre><code>status-line = HTTP-version SP status-code SP reason-phrase CRLF\n</code></pre>\n<ul>\n<li>status-code: 3 digits</li>\n<li>reason-phrase  = *( HTAB / SP / VCHAR / obs-text )</li>\n</ul>\n<p>Reason phrase is used to provide a description  to the status code.\nexamples: 200 Ok, 403 Forbidden, 429 Too many Requests...</p>\n<h3>Header-field</h3>\n<p>Each header field consists of a case-insensitive field name followed\nby a colon (":"), optional leading whitespace, the field value, and\noptional trailing whitespace.</p>\n<pre><code> field-name ":" *(x20) field-value *(x20)\n</code></pre>\n<p>There\'s no set field order and the new field names can be defined.</p>\n<p> HTTP does not place a predefined limit on the length of each header\nfield or on the length of the header section as a whole Various ad hoc limitations on individual header\nfield length are found in practice.</p>\n<p>A server that receives a request header field, or set of fields,\nlarger than it wishes to process MUST respond with an appropriate 4xx\n(Client Error) status code.  Ignoring such header fields would\nincrease the server\'s vulnerability to request smuggling attacks.</p>\n<h2>Message-body</h2>\n<p>The message body (if any) of an HTTP message is used to carry the\npayload body of that request or response.  The message body is\nidentical to the payload body unless a transfer coding has been\napplied.</p>\n<ul>\n<li>\n<p>Request:</p>\n<p> The presence of a message body in a request is signaled by a\n<code>Content-Length</code> or <code>Transfer-Encoding</code> header field.</p>\n</li>\n<li>\n<p>Response:</p>\n<p> The presence of a message body in a response depends on both the\nrequest method to which it is responding and the response status code.\nHEAD responses do not have body</p>\n</li>\n</ul>\n<h2>Common Header Fields</h2>\n<h3>Transfer-Encoding</h3>\n<p>The Transfer-Encoding header field lists the transfer coding names\ncorresponding to the sequence of transfer codings that have been (or\nwill be) applied to the payload body in order to form the message\nbody. </p>\n<p>example: gzip, chunked</p>\n<p>indicates that the payload body has been compressed using the gzip\ncoding and then chunked using the chunked coding while forming the\nmessage body.</p>\n<h3>Content Length</h3>\n<p>When a message does not have a Transfer-Encoding header field, a\nContent-Length header field can provide the anticipated size, as a\ndecimal number of octet.</p>\n<h2>Reference</h2>\n<ul>\n<li>[specification](ref: <a href="https://tools.ietf.org/html/rfc7230">https://tools.ietf.org/html/rfc7230</a>)</li>\n</ul>',frontmatter:{date:"May 27, 2018",path:"/p/web/http-syntax",title:"Http Syntax",section:"web"}}},pathContext:{}}}});
//# sourceMappingURL=path---p-web-http-syntax-0f8d7fa1e6bdc6c75085.js.map