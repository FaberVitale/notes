{"version":3,"sources":["webpack:///path---p-js-promise-a26ee773231f97937357.js","webpack:///./.cache/json/p-js-promise.json"],"names":["webpackJsonp","466","module","exports","data","markdownRemark","html","frontmatter","date","path","title","section","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,ynFAAquEC,aAA4aC,KAAA,eAAAC,KAAA,gBAAAC,MAAA,UAAAC,QAAA,QAAgFC","file":"path---p-js-promise-a26ee773231f97937357.js","sourcesContent":["webpackJsonp([103456858148469],{\n\n/***/ 466:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>  A promise is an object that is a placeholder of a deferred computation.</p>\\n<h2>Invariants</h2>\\n<ol>\\n<li>a promise is in one of 3 <strong>mutually</strong> exclusive states: <em>fulfilled, rejected or pending</em></li>\\n<li>a promise <em>pending</em> can become either <em>fulfilled or rejected</em>.</li>\\n<li>if a Promise p is fulfilled <code>p.then(f, r)</code> will immediatly enqueue a Job to call the function <strong>f</strong></li>\\n<li>if a Promise p is rejected <code>p.then(f, r)</code> will immediatly enqueue a Job to call the function <strong>r</strong></li>\\n<li>r of f are executed even if an error occurs.\\nA promise is said to be settled if it is not pending.</li>\\n</ol>\\n<p>A promise it is resolved if it settled or if it has been <em>locked-in</em> to match the state of another promise.</p>\\n<p>Attempts to superficially mutate a resolved promise have no effect.</p>\\n<h2>API</h2>\\n<h3>Constructor</h3>\\n<p>  Argument passed to the constructor is called Executor and must be a function.\\nthe executor will define here some computation (sync or async)\\nand when done it will pass the result to resolve() if success\\nor the errror or whatever is used to signal it a failure to reject()\\nin case of error.</p>\\n<p>  <em>Example:</em></p>\\n<pre><code class=\\\"language-js\\\"> new Promise ( (resolve, reject) => {\\n   const computation = maybeAsync(...);\\n\\n   computation.onsuccess = resolve;\\n   computation.onerror = reject;\\n })\\n</code></pre>\\n<h3>Promise.resolve|reject</h3>\\n<ul>\\n<li><code>Promise.resolve(val)</code>: Returns a new promise immediatly fulfilled with value val</li>\\n<li><code>Promise.reject(err)</code>: returns a new promise immediatly rejected with error err </li>\\n</ul>\\n<h3>p.then(onfulfill, onrejection)</h3>\\n<p>  If p is resolved a PromiseJob is scheduled that executes the function onfulfill or onrejection, not both.</p>\\n<h3>p.catch(onrejection)</h3>\\n<p>  Equivalent to p.then(undefined, onrekection);</p>\\n<h3>Promise.all(iterable&#x3C;Promise<any>>)</h3>\\n<p>  Given an iterable of promises returns a promise that is fulfilled, if all the promises are resolved,\\nor rejection otherwise.\\nthe argument passed to onfulfill cb is an array of values the promises resolve to.</p>\\n<h3>Promise.race(iterable&#x3C;Promise<any>>)</h3>\\n<p>  Given an iterable of promises returns the a new promise that is resolved\\nwith the same outcome as the first promise that is resolved inside this iterable.</p>\\n<p>  <strong>Note:</strong> if an empty array is passed this promise will never <em>resolve</em></p>\\n<h3>Thenable</h3>\\n<p>  A promise-like object is called thenable and has  prop named <em>then</em> that is a function.</p>\",\"frontmatter\":{\"date\":\"May 27, 2018\",\"path\":\"/p/js/promise\",\"title\":\"Promise\",\"section\":\"js\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---p-js-promise-a26ee773231f97937357.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>  A promise is an object that is a placeholder of a deferred computation.</p>\\n<h2>Invariants</h2>\\n<ol>\\n<li>a promise is in one of 3 <strong>mutually</strong> exclusive states: <em>fulfilled, rejected or pending</em></li>\\n<li>a promise <em>pending</em> can become either <em>fulfilled or rejected</em>.</li>\\n<li>if a Promise p is fulfilled <code>p.then(f, r)</code> will immediatly enqueue a Job to call the function <strong>f</strong></li>\\n<li>if a Promise p is rejected <code>p.then(f, r)</code> will immediatly enqueue a Job to call the function <strong>r</strong></li>\\n<li>r of f are executed even if an error occurs.\\nA promise is said to be settled if it is not pending.</li>\\n</ol>\\n<p>A promise it is resolved if it settled or if it has been <em>locked-in</em> to match the state of another promise.</p>\\n<p>Attempts to superficially mutate a resolved promise have no effect.</p>\\n<h2>API</h2>\\n<h3>Constructor</h3>\\n<p>  Argument passed to the constructor is called Executor and must be a function.\\nthe executor will define here some computation (sync or async)\\nand when done it will pass the result to resolve() if success\\nor the errror or whatever is used to signal it a failure to reject()\\nin case of error.</p>\\n<p>  <em>Example:</em></p>\\n<pre><code class=\\\"language-js\\\"> new Promise ( (resolve, reject) => {\\n   const computation = maybeAsync(...);\\n\\n   computation.onsuccess = resolve;\\n   computation.onerror = reject;\\n })\\n</code></pre>\\n<h3>Promise.resolve|reject</h3>\\n<ul>\\n<li><code>Promise.resolve(val)</code>: Returns a new promise immediatly fulfilled with value val</li>\\n<li><code>Promise.reject(err)</code>: returns a new promise immediatly rejected with error err </li>\\n</ul>\\n<h3>p.then(onfulfill, onrejection)</h3>\\n<p>  If p is resolved a PromiseJob is scheduled that executes the function onfulfill or onrejection, not both.</p>\\n<h3>p.catch(onrejection)</h3>\\n<p>  Equivalent to p.then(undefined, onrekection);</p>\\n<h3>Promise.all(iterable&#x3C;Promise<any>>)</h3>\\n<p>  Given an iterable of promises returns a promise that is fulfilled, if all the promises are resolved,\\nor rejection otherwise.\\nthe argument passed to onfulfill cb is an array of values the promises resolve to.</p>\\n<h3>Promise.race(iterable&#x3C;Promise<any>>)</h3>\\n<p>  Given an iterable of promises returns the a new promise that is resolved\\nwith the same outcome as the first promise that is resolved inside this iterable.</p>\\n<p>  <strong>Note:</strong> if an empty array is passed this promise will never <em>resolve</em></p>\\n<h3>Thenable</h3>\\n<p>  A promise-like object is called thenable and has  prop named <em>then</em> that is a function.</p>\",\"frontmatter\":{\"date\":\"May 27, 2018\",\"path\":\"/p/js/promise\",\"title\":\"Promise\",\"section\":\"js\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/p-js-promise.json\n// module id = 466\n// module chunks = 103456858148469"],"sourceRoot":""}