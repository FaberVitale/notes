webpackJsonp([20513165102579],{468:function(n,e){n.exports={data:{markdownRemark:{html:'<h2>Nomenclature</h2>\n<h3>Execution context</h3>\n<p>  a record created during function invocation.\nit holds information about where and how the function was invoked,\narguments passed, a reference to this etc...</p>\n<h3>Call-stack</h3>\n<p>  stack of function called at a specific instant during execution of a program\nOn top is the function running at <em>that</em> instant. elements of the stack are called\nstack frames.</p>\n<h3>Call-site</h3>\n<p>  where a function is called.\nit is not be always transparent where\'s located without a debugger.</p>\n<h2>How it works?</h2>\n<p>  This is dynamically bound at the call-site of a function, using the following rules.</p>\n<h3>Default Binding</h3>\n<p>  In a function</p>\n<ul>\n<li>in <em>lazy mode</em> this refers to the global object, </li>\n<li>in <em>strict mode</em> this refers to undefined.</li>\n</ul>\n<p>  Only the global object is elegible to the default binding,\n<strong>not</strong> the this of the execution context if it isnt the global object. </p>\n<pre><code class="language-js">  //lazy mode\n  const logThis = function () { \n    console.log(this);\n  }\n\n  const func = function () { \n    logthis(); \n  };\n\n  func(); // prints the global object\n  func.call({}); // prints the global object\n</code></pre>\n<h3>Implicit Binding</h3>\n<p>  if an object <code>a</code> holds a reference to a function <code>b</code> and the call-site is  <code>a.b()</code>.</p>\n<p>  <code>a</code> is said to <em>own</em> b.\nIn this case this points to the object <code>a</code></p>\n<pre><code class="language-js">  // global scope\n  let c = 0;\n  const exec = (func) => {\n    if(typeof func === "function") {\n      func();\n    }\n  }\n\n  const foo = function(){ \n    console.log(this.c);\n  };\n\n  const a = {\n    c: 1,\n    b: foo\n  };\n\n  a.b(); // logs 1\n  (a.b)(); // logs 1\n\n  // Implicit Lost due to reference copy\n\n  let d;\n  exec(a.b) // logs 0 call-site is func()\n  (d = a.b)(); // logs 0 equivalent to d = foo; d();\n</code></pre>\n<h3>Explicit Binding</h3>\n<ul>\n<li>call: <em>Function.prototype.call(thisArg: any, ...args: Array&#x3C;any>)</em></li>\n<li>apply <em>Function.prototype.apply(thisArgs: any, args: Array&#x3C;any>)</em></li>\n</ul>\n<p>  are a way to explicitly set the context at the call-site.</p>\n<p>  Another tool to hard bind a context, bypassing the call-site problem is a helper\nmethod called <em>bind</em> that is In the prototype of Function.\nIt is used to partially apply this and the other arguments of a function.\nA bounded function will ignore this from the call-site and use the bounded one. </p>\n<h3>new Binding</h3>\n<p>  a function invoked using the new keyword will always have this pointing at the new object.\nTechnically a constructor in js is just a function that is preceded by a <em>new</em> keyword.</p>\n<p>  Whenever a function is invoked with a <em>new</em> keyword the following steps occur:</p>\n<ol>\n<li>a brand-new object is created.</li>\n<li>this object is <code>[[Prototype]]</code> linked.</li>\n<li>this object is the context of the constructor function.</li>\n<li>the body of the function is executed.</li>\n<li>unless the function returns another object this new object is returned.</li>\n</ol>\n<p>  Technically new creates a binding.</p>\n<h3>Order of Precedence</h3>\n<p>  determining <em>this</em> reference given the call-site.</p>\n<ol>\n<li>\n<p>in precence of a <strong>new binding</strong> this will point to the newly created object</p>\n</li>\n<li>\n<p>if an explicit bound is present this will point to the specified   object.        bounded functions using <em>bind()</em> have higher precedence over <em>call()/apply()</em></p>\n</li>\n<li>\n<p>function called with an <em>implicit binding</em>  <code>e.g. a.b()</code> where a owns a reference to the function whose b is pointing to, will have the this pointing to the owner oject.</p>\n</li>\n<li>\n<p><strong>default binding</strong> this will point to the global object in lazy mode and undefined in strict mode.</p>\n</li>\n</ol>\n<h3>Exceptions</h3>\n<p>  Passing null or undefined to <code>call()/bind()/apply()</code> will makes the functions use the default binding rule.\nit was useful before es6 introduced spreading operator.</p>\n<h2>Arrow functions and context</h2>\n<p>  capture the value of this from the execution context\nits value <strong>cannot be rebinded in any way</strong>(not  even with <em>new</em>).\nAs consequence arrow functions cannot be constructors (it throws an error)\nand explicit binidings (call/bind/apply) ae silently ignored</p>\n<pre><code class="language-js">  function logDelayed() {\n    setTimeout( () => {console.log(this);}, 50);\n  }\n\n  const a = { b: logDelayed};\n\n  a.b(); // logs a obj\n  logDelayed.call({}); // logs {}\n  logDelayed(); // logs undefined in strict global object in lazy\n  (() => {console.log(this)}).bind("hi!")(); // bind is ignored\n</code></pre>',frontmatter:{date:"May 27, 2018",path:"/p/js/this",title:"What's This?",section:"js"}}},pathContext:{}}}});
//# sourceMappingURL=path---p-js-this-7e7a03eb907cc8017f54.js.map